# app/api/v1/auth.py

from datetime import datetime, timedelta
from typing import Dict, Any

from fastapi import APIRouter, Depends, HTTPException, Request, status
from fastapi.security import OAuth2PasswordRequestForm
from jose import JWTError, jwt
from pydantic import BaseModel

# --- Local Application Imports ---
from app.core.config import settings
from app.schemas.auth import Token  # Assuming this Pydantic model exists

# --- Rate Limiting ---
# In a larger app, you would define the limiter once in a central place
# (e.g., app/main.py or app/core/config.py) and import it.
from slowapi import Limiter
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)


# --- Pydantic Models ---

# It's good practice to have a model for your user data.
# In a real app, this would likely be in app/schemas/users.py
class User(BaseModel):
    username: str
    email: str | None = None
    full_name: str | None = None
    disabled: bool | None = None


class UserInDB(User):
    password_hash: str


# --- Database Placeholder ---

# This is a fake database. In a real application, you would query your actual database.
fake_users_db: Dict[str, Dict[str, Any]] = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        "password_hash": "fakehashedsecret", # IMPORTANT: Use a real hash in production!
        "disabled": False,
    }
}


# --- Utility Functions ---

def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    """
    Generates a JWT access token.

    Args:
        data: The payload to include in the token (e.g., {"sub": username}).
        expires_delta: Optional timedelta for token expiration. 
                       Defaults to 15 minutes if not provided.

    Returns:
        The encoded JWT string.
    """
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


def verify_password(plain_password: str, password_hash: str) -> bool:
    """
    Verifies a plain password against a hashed password.

    NOTE: This is a placeholder. In a real application, you MUST use a
    strong hashing library like `passlib` with `bcrypt`.

    Example with passlib:
    from passlib.context import CryptContext
    pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
    return pwd_context.verify(plain_password, password_hash)
    """
    # For this example, we'll use a simple, insecure comparison.
    # The "hashed" password in the fake DB is just the plain password with a prefix.
    return f"fakehashed{plain_password}" == password_hash


def get_user(db: dict, username: str) -> UserInDB | None:
    """
    Retrieves a user from the database by username.
    """
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)
    return None


# --- Authentication Dependencies ---

async def get_current_user(request: Request, token: str = Depends(OAuth2PasswordRequestForm)):
    """
    Dependency to decode JWT token and retrieve the current user.
    This is a simplified example. A more robust solution would use a
    `Bearer` token from the `Authorization` header.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        # In a real app, the token would be extracted from the Authorization header
        # payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        # username: str = payload.get("sub")
        # For this example using OAuth2PasswordRequestForm, we get the username directly
        username = token.username
        if username is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    user = get_user(fake_users_db, username=username)
    if user is None:
        raise credentials_exception
    return user


# --- API Router ---

router = APIRouter()


@router.post("/token", response_model=Token)
@limiter.limit("5/minute")  # Apply rate limiting to prevent brute-force attacks
async def login_for_access_token(request: Request, form_data: OAuth2PasswordRequestForm = Depends()):
    """
    Authenticates a user and returns an access token.

    This endpoint is rate-limited to 5 attempts per minute per IP address.
    """
    user = get_user(fake_users_db, form_data.username)
    if not user or not verify_password(form_data.password, user.password_hash):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


@router.get("/users/me", response_model=User)
async def read_users_me(current_user: User = Depends(get_current_user)):
    """
    Retrieves the details of the currently authenticated user.
    This endpoint is protected and requires a valid token.
    """
    return current_user
1